# week2 :: time complexity & sort

## 시간복잡도 (time complexity)

### 알고리즘

* **문제**를 **해결**하기 위한 **절차**
* ex) 서울에서 제주도까지 가려면 어떻게 해야 하나요?
*  - 비행기를 타고 간다 : 서울의 어디에서나 비행기를 탈 수 있는 것이 아님. 즉, 문제가 무엇인지 정확히 이해하는 것이 중요
*  그렇다면 알고리즘은 구체적일 수록 좋은 것인가?

#### 알고리즘 != 프로그래밍

* 알고리즘을 설명할 때는 청자가 사람이라는 사실을 고려한다.
  * 프로그램도 결국 문제를 해결하는 과정을 기술한 것이지만 기계를 대상으로 하는 설명일 뿐
  * 핵심 아이디어를 중심으로 어느 정도까지 세부적으로 설명할 지를 생각
* 알고리즘을 이해하되, 어떻게 구현할지 생각해본다.
  * 구현에 익숙하지 않다면 알고리즘의 각 단계를 어떻게 구현할지도 고려
  * 적합한 자료구조를 이용하여 구현 가능 : 알고리즘 공부와 자료구조 공부는 동시에 병행돼야함.

#### 알고리즘의 성립 조건
1. 항상 올바른 담을 낼 것
2. 유한한 시간 안에 종료될 것 (무한루프 x)

#### 좋은 알고리즘이란?
* 누구나 쉽게 이해할 수 있어야 하며, 간결해야함(나만 아는 알고리즘x) -> 재이용, 유지보수가 쉬움
* 주어진 자원의 한계를 생각해야 함 : 하드웨어(메모리, 클럭 속도) 등 주어진 자원을 고려하는 알고리즘
* 알고리즘을 수행하는 데에 걸리는 시간을 생각해야 함 : 수행 시간이 빠른 알고리즘
* 따라서 **속도**가 빠른 알고리즘을 우선으로 살펴봄
<br/>

* 어떤 알고리즘이 더 빠를까?
```
int sun(int n){
  int result=0; //0번(대입연산은 세지 않음)
  for (int i=1; i<=n; i++){ //+2
    	for (int j=1; j<=i; j++)	result++; //3i+1 
  }
  return result;
  // (3i+1+2)+1 = 1.5n^2 + 4.5n + 2
```
```
int sum(int n){
 int result=0;
    
 for (int i=1; i<=n; i++)	result += i; //한 번 반복할 때 3번 연산
 return result;
}
// 3n+1
```
1. 비교적 큰 수에서는 n의 차수가 클수록 식이 크다.
2. 상수와 계수들을 뺀 최고차항을 고려해도 같은 결과를 얻는다.
3. 즉 새로운 기호의 도입 필요 -> **Big-O** 표기법
```적당히 큰 x에 대해서 대략적으로 f(x)보다 g(x)이 크다```
<br/>

* 적당히 큰 수에 대해서는 f(n)의 증가량이 g(n)의 증가량을 넘지 않는다.
* 대략적인 f(n)의 상한을 알 수 있다. 즉 **c * g(n)이 f(n)의 상한**
* 서로 다른 알고리즘의 시간 복잡도를 쉽게 비교할 수 있다.
* 자주 사용하는 시간 복잡도 표기

|Big-O||
|---|---|
|O(1)|상수 시간(Constant time)|
|O(logN)|로그 시간(대수 시간, Logarithmic time)|
|O(N)|선형 시간(Linear time)|
|O(NlogN)|로그 선형 시간(Log-linear time)|
|O(n^2)|제곱 시간(Quadratic time)|
|O(n^3)|세제곱 시간(Cubic time)|
|O(2^n)|지수 시간(Exponential time)|

<br/><br/>

## 정렬 (sort)
어떤 기준에 따라서 순서를 재배치하는 것 : 자료에 쉽게 접근하거나 자료를 편하게 이용할 수 있음

### 버블 정렬 (bubble sort) : 시간복잡도 O(n^2)
* 다음을 n-1번 반복한다.
 * 앞에서부터 인접한 두 개를 비교하면서 올바른 순서가 되도록 한다. (9,4) -> (4,9)
 * 현재 i번째 반복을 수행하는 경우 끝에서 i번째 원소를 제외하고 비교해도 된다.
* 올바른 알고리즘일까? (버블 정렬의 정당성)
 * 매번 반복할 때마다 가장 큰 수가 제일 뒤로 간다
 * 뒤에서부터 n-1개가 올바른 자리를 찾아갔다는 것은 모든 원소가 제자리를 찾았다고 할 수 있음
```
void bubbleSort(int arr[], int n){
 for (int i=0; i<n; i++){ //대략 c*n*n번 
  for (int j=0; j<n-i-1; j++){ //대략 c*n번
   if (arr[j] > arr[j+1]){ //적당히 4개?
   int temp = arr[j];
   arr[j] = arr[j+1];
   arr[j+1] = temp;
  }
 }
} //O(n^2)
``` 
<br/>

### 삽입 정렬 (insertion sort) : 시간복잡도 O(n^2)
* 다음을 n-1번 반복한다.
 * 현재 i번째 반복을 수행하는 경우 i번째 원소를 앞의 원소들과 역순으로 차례차례 비교한다.
 * 처음으로 등장하는 i번째 원소보다 크지 않은 원소의 뒤에 i번째 원소를 위치시킨다.
 * (즉 자신과 자신 앞에있는 수랑 역순으로 비교하고 맞는 자리에 끼워넣음)
* 올바른 알고리즘일까?
 * 매번 반복할 때마다 앞의 배열이 정렬된다.
 * 즉 현재 위치까지 정렬하면 현재 위치와 그 앞의 수는 모두 정렬된 상태이다.
 ```
 void insertionSort(int arr[], int n){
	for (int i=0 ; i<n ; i++){
    	int temp = arr[i]; // 정렬할 수를 임시변수에 빼놓음
    	int j;
    	for (j=i ; j>0 ; j--){ // 정렬할 수보다 큰 수를 모두 뒤로 한 칸씩 민다
    		if (arr[j-1] <= temp)	break;
    	 arr[j] = arr[j-1];
    	}
    arr[j] = temp; // 빈 자리에 임시변수에 빼놨던 수를 넣음
    }
} // O(n^2)
```

+) 삽입정렬이 버블정렬보다 좋을 때
1. 배열이 적당히 정렬되어 있을 때 : ( 2, 3, 4, 5, 6, 1 )와 같이 정렬되어 있는 경우 삽입정렬이 더 용이함
2. 배열에 있는 모든 원소가 자신의 위치와 최대 k개 떨어져 있을 때

<br/>

### 병합 정렬 (merge sort) : 시간복잡도 O(NlogN)

* 다음과 같이 진행한다.
 * 정렬해야 할 배열의 크기가 1이라면 종료한다.
 * 그렇지 않으면 배열을 같은 크기로 나눈다. (홀수 개인 경우 한 개 차이나게 적당히)
 * **나눈 각각의 배열에서 병합 정렬을 수행한다. (재귀적)**
 * 정렬한 두 개 배열 각각의 첫 번째 원소부터 차례로 비교하여 전체 배열을 정렬한다.
* 예시 (좌측절반인 9 4 3 8을 정렬하는 과정)

|||||||||
|---|---|---|---|---|---|---|---|
|**9**|**4**|**3**|**8**|5|2|1|7|
|**4**|**9**|3|8|5|2|1|7|
|4|9|**3**|**8**|5|2|1|7|
|**3**|**4**|**8**|**9**|5|2|1|7|

이하생략
```
void mergeSort(int arr[], int l, int r){
	if (l == r-1)	return; // 정렬해야 할 배열의 크기가 1이면 종료
    int m = (l+r)/2;
    mergeSort(arr, l, m); // 왼쪽 segment
    mergeSort(arr, m, r); // 오른쪽 segment
    //[l, m), [m,r]이 잘 정렬됨 
    
    merge(arr, l, m, r); // 각각의 segment가 잘 정렬되어 있을 때 기존 배열을 정렬 
}

void merge(int arr[], int l, int m, int r){
	int idx1, idx2, idx3;
    idx1 = idx3 = l;
    idx2 = m;
    
    while (idx1 < m && idx2 < r){
    	if (arr[idx1] < arr[idx2])	tmp[idx3++] = arr[idx1++]; //tmp는 원래 배열 arr와 같은 크기
        else 				tmp[idx3++] = arr[idx2++];
    }
    
    // 한 쪽 segment 요소를 다 쓴 경우
    while (idx1 < m)	tmp[idx3++] = arr[idx1++];
    while (idx2 < r)	tmp[idx3++] = arr[idx2++];
    
    for (int i=1; i<r; i++)	arr[i] = tmp[i];
}
```

* arr[]

|||||||||
|---|---|---|---|---|---|---|---|
|**3**|4|8|9|**1**|2|5|7|

* tmp[]

|||||||||
|---|---|---|---|---|---|---|---|
|**1, 3 비교**|3, 2 비교|3, 5 비교|4, 5 비교|8, 5 비교|8, 7 비교|8, 9 비교||
|**1**|2|3|4|5|7|8|9|

* 이 때 시간복잡도는
 * 전체 머지 소트는 n-1번 불림
 * 밑이 2인 log개의 단계, 즉 O(logN)
 * 각 단계마다 O(N)의 시간
 * 따라서 O(NlogN)

<br/><br/><br/>

+) std::sort 함수
sort(배열의 이름, 배열의 이름+배열의 크기)
```
std::vector<int> v;

void stl_sort_vector(){
	std::sort(v.begin(), v.end());
}

void stl_sort_array(int arr[], int n){
	std::sort(arr, arr+n);
}
```

<br/><br/><br/>

# 과제
* basic
(02751 수 정렬하기2 (실버5))

10825 국영수 (실버4)

10610 30 (실버5)

<br/>

* advanced
02437 저울 (골드3)

11582 치킨 TOP N (실버4)

01377 버블 소트 (골드3)

01448 삼각형 만들기 (실버3)


