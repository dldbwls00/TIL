<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>JS Reference VS Copy</title>
        <link rel="icon" href="https://fav.farm/ğŸ”¥" />
    </head>
    <body>
        <script>
            // start with strings, numbers and booleans
            let age = 100;
            let age2 = age;
            console.log(age, age2);
            age = 200;
            console.log(age, age2); //ê°’ ì „ë‹¬

            let name = 'wes';
            let name2 = name;
            console.log(name, name2);
            name = 'wesley';
            console.log(name, name2); //stringë„ ë§ˆì°¬ê°€ì§€
            
            // Let's say we have an array
            const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

            // and we want to make a copy of it.
            const team = players;

            // You might think we can just do something like this:
            team[3] = 'Lux'; 
                //playersê¹Œì§€ ì—…ë°ì´íŠ¸ë¨ -> ì°¸ì¡° ì „ë‹¬
                //teamì€ arrayê°€ ì•„ë‹˜, reference to the original array(players)

            // however what happens when we update that array?

            // now here is the problem!

            // oh no - we have edited the original array too!

            // Why? It's because that is an array reference, not an array copy. They both point to the same array!

            // So, how do we fix this? We take a copy instead!
            const team2 = players.slice(); 
                //ì¸ì ì „ë‹¬í•˜ì§€ ì•Šìœ¼ë©´ actual arrayì˜ copy -> ê°’ ì „ë‹¬
                //team2ë¥¼ ìˆ˜ì •í•´ë„ playersê°€ ë°”ë€Œì§€ ì•ŠìŒ
            

            // one way

            // or create a new array and concat the old one in
            const team3 = [].concat(players);
                //ë˜ ë‹¤ë¥¸ ë°©ë²• : ë¹ˆ ë°°ì—´ì— ë¶™ì—¬ë„£ìŒ

            // or use the new ES6 Spread
            const team4 = [...players];
                //take the every item out of your iterable and put it into the containing array
            team4[3] = 'heee haww!';
            console.log(team4);

            const team5 = Array.from(players); //players untouched, team5 updated

            // now when we update it, the original one isn't changed

            // The same thing goes for objects, let's say we have a person object

            // with Objects
            const person = {
            name: 'Wes Bos',
            age: 80
            };

            // and think we make a copy:
            const captain = person;
            captain.number = 99; //ê°’ ì „ë‹¬, personì´ ë³€ê²½ë”¤

            // how do we take a copy instead?
            const cap2 = Object.assign({}, person, { number: 99, age: 12 }); 
                //ë¹ˆ ê³³ì— personì„ override and fold in all of the properties and values from our object
                //and then we use the third argument to fold in our own ones
            console.log(cap2);

            // We will hopefully soon see the object ...spread
            const cap3 = {...person};

            // Things to note - this is only 1 level deep - both for Arrays and Objects. 
            // lodash has a cloneDeep method, but you should think twice before using it.
            const wes = {
                name: 'wes',
                age: 100,
                social: {
                    twitter: '@wesbos',
                    facebook: 'weskj'
                }
            }
            console.clear();
            console.log(wes);

            const dev = Object.assign({}, wes); 
            //nameì„ ë°”ê¿”ë„ original(wes)ì€ ë°”ê·€ì§€ ì•ŠìŒ
            //twitterëŠ” ë°”ê¾¸ë©´ wesë„ ê°™ì´ ë°”ë€œ <??
            //Object.assign()ì€ 1 level deep, deep cloneì„ í•´ì•¼í•¨

            const dev2 = JSON.parse(JSON.stringify(wes));
            //ì´ê±¸ë¡œ ì‚¬ìš©í•˜ë©´ ë°”ë€Œì§€ ì•ŠìŒ!
            //objectë¥¼ stringìœ¼ë¡œ ë°”ê¿”ì£¼ê¸° ë•Œë¬¸ -> full copy

        </script>
    </body>
</html>